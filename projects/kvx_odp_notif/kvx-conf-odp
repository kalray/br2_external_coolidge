#!/bin/bash

set -eu

script_name=$(basename "$0")
odp_notif_path=/sys/devices/odp_notif

function echoerr() {
	printf "%s\n" "$*" >&2
}

if [[ ${BASH_VERSINFO[0]} -lt 4 || (
	${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -lt 4 ) ]]; then
	echoerr "ERROR: $script_name requires a minimal 4.4 bash version"
	exit 1
fi

split_trigger=256
nb_rx_queues=16
declare -a cluster_ids=()
declare -a eth_ids=()

commands="config ready print-weights print-mask reset-dt"

usage() {
	cat <<EOF
Configuration script for ODP firmwares and ethernet interfaces.
WARNING: firmwares must have been started before calling this script.

$script_name command [options]

Commands:
config        : configure cluster(s) and ethernet interfaces
ready         : send a ready command to the cluster(s)
print-weights : print rx queues in \`ethtool -X weight\` format
print-mask    : print rx_channel ids mask
reset-dt      : reset dispatch table

  config
  ======

Configure one or serveral cluster and ethernet load balancer in config mode,
both ethernet interfaces for a cluster can be configured in one or two times
this mode requires firmware are started on clusters

On each configured cluster:
  - ODP firmware must have been started
  - odp_init_global must called with following options
     .init_rproc = 1
     .wait_eth_config = 1
  - firmware is blocked in odp_init_global, waiting for
    ready command

Options:

	-c, --cluster-ids   id0[,idn]: list of cluster ids separated by commas
	                               (cluster 0 is forbidden) REQUIRED
	-e, --eth-ids       id0[,idn]: list of ethernet interface ids separated by
	                               commas REQUIRED
	-n, --nb-rx-queues  N        : set the number of Rx queues for each ethernet
	                               interface on each cluster
	                               (default $nb_rx_queues)
	-s, --split-trigger N        : split trigger, in bytes. It must be a
	                               multiple of 16 (default $split_trigger)

Examples:

Configure eth0 and eth1 for clusters 1, 2, 3 and 4 with default nb rx queues
$script_name config --cluster-ids 1,2,3,4 --eth-ids 0,1
Configure cluster 1 with different nb rx queues on both eth interfaces
$script_name config --cluster-ids 1 --eth-ids 0 --nb-rx-queues 10
$script_name config --cluster-ids 1 --eth-ids 1 --nb-rx-queues 14

  ready
  =====

The ODP firmware is blocked in odp_init_global, waiting for a ready command.
This command send a ready command to the firmware, letting it continue.

Options:

	-c, --cluster-ids   id0[,idn]: list of cluster ids separated by commas
	                               (cluster 0 is forbidden) REQUIRED

Examples:

$script_name ready --cluster-ids 1,2,3,4

  print-weights
  =============

Each ethernet interface must link the LUT (lookup table) and the dispatch table.
To do so, \`ethtool -X weight\` command must be used.
print-weights will print all the dispatch entries in the good format.

WARNING: it must be called once all the clusters have been configured

Options:

	-e, --eth-id        id: ethernet interface id REQUIRED

Examples:

ethtool -X eth0 weight \$($script_name print-weights --eth-id 0)
ethtool -X eth1 weight \$($script_name print-weights --eth-id 1)


  print-mask
  ==========

Print rx_channel ids mask as it would been set for a given ethernet interface
and a number of rx queues.
This mask will be used to retrieve the pktin queue id on a cluster, given its
cluster_id/rx_channel_id.
WARNING: the printed value is recomputed, it is not taken from the
configuration. If you set a different --nb-rx-queues than when you configured
the cluster, you will have a different mask.

Options:

	-e, --eth-id        id: ethernet interface id REQUIRED
	-n, --nb-rx-queues  N : set the number of Rx queues for each ethernet
	                        interface on each cluster REQUIRED

Examples:

$script_name print-mask --cluster-id 1 --eth-id 1

  reset-dt
  ========

Reset the dispatch table for a given ethernet interface.

Options:

	-e, --eth-ids       id0[,idn]: list of ethernet interface ids separated by
	                               commas REQUIRED

Examples:

$script_name reset-dt --eth-id 0

  General options
  ===============

	-v, --verbose                : run scrip in verbose mode
	-h, --help                   : show this help
EOF
}
LONG_LIST="cluster-ids:,eth-ids:,split-trigger:,nb-rx-queues:,verbose,help"
SHORT_LIST="c:e:s:n:vh"

OPTS=$(getopt -o $SHORT_LIST --long $LONG_LIST -n 'parse-options' -- "$@")

if [ $? != 0 ] ; then echoerr "Failed parsing options." ; exit 1 ; fi

eval set -- "$OPTS"

nb_rx_queues_ow=false
split_trigger_ow=false

while true; do
	case "$1" in
		-v | --verbose )   set -x; shift ;;
		-h | --help )      usage; exit ;;
		-c | --cluster-ids )
			IFS=',' read -r -a cluster_ids <<< "$2"
			shift; shift
			;;
		-e | --eth-ids )
			IFS=',' read -r -a eth_ids <<< "$2"
			shift; shift
			;;
		-n | --nb-rx-queues )
			nb_rx_queues=$2
			shift; shift
			# shellcheck disable=SC2034
			nb_rx_queues_ow=true
			;;
		-s | --split-trigger )
			split_trigger=$2
			shift; shift
			# shellcheck disable=SC2034
			split_trigger_ow=true
			;;
		-- ) shift; break ;;
		* ) echoerr "option $1 does not exist"; print_help; exit 1;;
	esac
done

if [ $# == 0 ]; then
	echoerr "ERROR: no command provided"
	exit 1
fi

command=$1
if ! [[ " ${commands} " =~ \ ${command}\  ]]; then
	echoerr "ERROR: '$command' is not a valid command"
	exit 1
fi

function check_param() {
	local param_name=$1
	local min=$2
	local max=$3

	local p
	local -n param=${param_name}
	for p in "${param[@]}"; do
		if [[ ${p} -lt ${min} || ${p} -gt ${max} ]]; then
			echoerr "ERROR: ${param_name} value ${p} is not in [${min}..${max}]"
			exit 1
		fi
	done
}

check_param cluster_ids 1 4
check_param eth_ids 0 1
check_param nb_rx_queues 1 16
check_param split_trigger 0 1024
if [[ $(( split_trigger % 16 )) != 0 ]]; then
	echoerr "Error: split-trigger '$split_trigger' must be multiple of 16"
	exit 1
fi


function get_sys_net_path() {
	local eid=$(( $1 * 4 ))
	for i in /sys/class/net/*/phys_port_name; do
		if [[ "$(cat "$i" 2> /dev/null)" == "enmppa${eid}" ]]; then
			dirname "$i"
			return
		fi
	done
	echoerr "ERROR: Can not find 'enmppa${eid} in '/sys/class/net/*/phys_port_name'"
	exit 1
}

function config_disptach_table() {
	local cid=$1
	local eid=$2

	local disp_tbl_base=$(( (cid-1)*16 ))
	local rx_chan_base=$(( 32*eid ))
	local disp_tbl_path
	disp_tbl_path=$(get_sys_net_path "$eid")/dispatch_table

	for i in $(seq 0 $(( nb_rx_queues - 1 )) ); do
		local rx_chan=$(( rx_chan_base + i * 2 ))
		local disp_tbl_id=$(( disp_tbl_base + i ))
		local p
		p=$disp_tbl_path/${disp_tbl_id}
		echo "${cid}" > "$p/cluster_id"
		echo "${rx_chan}" > "$p/rx_channel"
		echo $(( split_trigger / 16 )) > "$p/split_trigger"
	done
}

function config_tx_fifo() {
	local cid=$1
	local eid=$2
	local p
	p=$(get_sys_net_path "$eid")/tx/${cid}

	echo 0 > "$p/drop_en"
}

function print_rx_mask() {
	local eid=$1
	printf "0x%x" $(( (0x55555555 >> (16-nb_rx_queues)*2) << (eid*32) ))
}

function config_cluster_eth() {
	local cid=$1
	local eid=$2
	local p=${odp_notif_path}/cluster${cid}/eth${eid}
	local rx_mask
	local sys_net_path=$(get_sys_net_path "$eid")
	rx_mask=$(print_rx_mask "$eid")

	# MAC address
	echo 7 > "$p/type"
	mac_str=$(cat "$sys_net_path/address")
	echo "$mac_str" > "$p/mac_address"
	echo 1 > "$p/send_notif"

	# TX CONF
	echo 2 > "$p/type"
	echo 0 > "$p/tx_asn"
	echo "$cid" > "$p/tx_fifo_id"
	echo 1 > "$p/tx_header_enabled"
	echo 1 > "$p/send_notif"

	# RX CONF
	echo 1 >   "$p/type"
	echo "$split_trigger" > "$p/rx_split_trigger"
	echo "$rx_mask" > "$p/rx_ids_small"
	echo 0 >   "$p/rx_asn"
	echo 1 >   "$p/send_notif"

	echo 0 >   "$p/type"
	for parser_id in $(\ls -v1 "$sys_net_path/parser/"); do
		if [[ $(cat "$sys_net_path/parser/$parser_id/enable") == 1 ]]; then
			echo "$parser_id" > "$p/parser_id"
			cat "$sys_net_path/parser/$parser_id/desc" > "$p/parser_desc"
			echo 1 >   "$p/send_notif"
		fi
	done

	# ETH AVAILABLE
	echo 5 > "$p/type"
	echo 1 > "$p/available"
	echo 1 > "$p/send_notif"
}

function wait_cluster() {
	local cid=$1
	if [[ $cid -lt 1 || $cid -gt 4 ]]; then
		echoerr "Error: invalid cluster id $cid"
		exit 1
	fi
	echo -n "Waiting for cluster $cid to be ready"
	while ! { [ -r "${odp_notif_path}/cluster${cid}/cluster_ready" ] && \
		[ "$(cat "${odp_notif_path}/cluster${cid}/cluster_ready")" == "1" ] ;} ; do
			echo -n .
			sleep 1
	done
	echo ""

	if [ "$(cat "${odp_notif_path}/cluster${cid}/config_done")" == "1" ]; then
		echoerr "Error: cluster $cid has already been configured"
		exit 1
	fi
}

function config_eth_lb() {
	local eid=$1
	local lane_id=$2
	local p
	p="$(get_sys_net_path "$eid")/lb/$lane_id"

	echo 1 > "$p/add_header"
	echo 0 > "$p/add_footer"
	echo 1 > "$p/store_and_forward"
	echo 1 > "$p/keep_all_crc_error_pkt"
	# echo 1 > $p/default_dispatch_policy
}

function valid_cluster() {
	local cid=$1
	local p=${odp_notif_path}/cluster${cid}
	echo 1 > "$p/config_done"
}

function print_weights() {
	local eid=$1
	local p

	p=$(get_sys_net_path "${eid}")
	cat "${p}/dispatch_table_acc/weights"
	exit
}

function reset_dt() {
	local eid=$1
	local p
	p=$(get_sys_net_path "${eid}")
	echo 1 > "${p}/dispatch_table_acc/reset"
}

function check_param_nb_val() {
	local param_name=$1
	local min=$2
	local max=$3
	local -n param=${param_name}
	if [[ ${#param[@]} -lt ${min} || ${#param[@]} -gt ${max} ]]; then
		echoerr "ERROR: for $command command, ${param_name} must have [${min}..${max}] values, not ${#param[@]}"
		exit 1
	fi
}

function check_param_ow() {
	local param_name=$1
	local -n param_ow=${param_name}_ow
	if [[ ${param_ow} == false ]]; then
		echoerr "ERROR: ${param_name} is required"
		exit 1
	fi
}

function config_extra_payload_wa() {
	local cid=$1
	local eid=$2
	local p=${odp_notif_path}/cluster${cid}/eth${eid}

	extra_payload_wa=$(grep -o -E "odp.extra_payload_wa=[0-2]"  /proc/cmdline | sed 's/odp.extra_payload_wa=//')

	echo 8 > "$p/type"
	echo ${extra_payload_wa:-0} > "$p/extra_payload_wa"
	echo 1 > "$p/send_notif"
}

case "$command" in
	config )
		check_param_nb_val cluster_ids 1 4
		check_param_nb_val eth_ids 1 2
		for e in "${eth_ids[@]}"; do
			config_eth_lb "$e" 0
		done
		for c in "${cluster_ids[@]}"; do
			for e in "${eth_ids[@]}"; do
				config_disptach_table "$c" "$e"
				config_tx_fifo "$c" "$e"
			done
		done
		for c in "${cluster_ids[@]}"; do
			wait_cluster "$c"
			for e in "${eth_ids[@]}"; do
				config_cluster_eth "$c" "$e"
			done
		done
		for c in "${cluster_ids[@]}"; do
			for e in "${eth_ids[@]}"; do
				config_extra_payload_wa "$c" "$e"
			done
		done
		;;
	ready )
		check_param_nb_val cluster_ids 1 4
		check_param_nb_val eth_ids 0 0
		for c in "${cluster_ids[@]}"; do
			valid_cluster "$c"
		done
		;;
	print-mask )
		check_param_nb_val eth_ids 1 1
		check_param_ow nb_rx_queues
		check_param_nb_val cluster_ids 0 0
		print_rx_mask "${eth_ids[0]}" "${eth_ids[0]}"
		;;
	print-weights )
		check_param_nb_val cluster_ids 0 0
		check_param_nb_val eth_ids 1 1
		print_weights "${eth_ids[0]}"
		;;
	reset-dt )
		check_param_nb_val cluster_ids 0 0
		check_param_nb_val eth_ids 1 2
		for e in "${eth_ids[@]}"; do
			reset_dt "$e"
		done
		;;
esac
